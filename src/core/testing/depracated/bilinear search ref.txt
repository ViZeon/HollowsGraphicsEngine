if (range_z.x == -1) {
    imageStore(outputImage, pixel, vec4(0.0, 0.0, 0.0, 1.0));
    return;
}

// Find 4 nearest vertices forming a quad around world_pos
float min_x_lower = 999999.0, min_x_upper = 999999.0;
float min_y_lower = 999999.0, min_y_upper = 999999.0;
int idx_tl = -1, idx_tr = -1, idx_bl = -1, idx_br = -1;

for (int i = range_z.x; i <= range_z.y; i++) {
    float vx = vertices[i].x;
    float vy = vertices[i].y;
    
    if (vx <= world_pos.x && vy <= world_pos.y) { // bottom-left
        float dist = (world_pos.x - vx) + (world_pos.y - vy);
        if (dist < min_x_lower + min_y_lower) {
            min_x_lower = world_pos.x - vx;
            min_y_lower = world_pos.y - vy;
            idx_bl = i;
        }
    }
    // Repeat for top-right, top-left, bottom-right quadrants
}

if (idx_tl == -1 || idx_tr == -1 || idx_bl == -1 || idx_br == -1) {
    imageStore(outputImage, pixel, vec4(0.0, 0.0, 0.0, 1.0));
    return;
}

// Bilinear interpolation
vec2 t = vec2(
    (world_pos.x - vertices[idx_bl].x) / (vertices[idx_br].x - vertices[idx_bl].x),
    (world_pos.y - vertices[idx_bl].y) / (vertices[idx_tl].y - vertices[idx_bl].y)
);

float z_bottom = mix(vertices[idx_bl].z, vertices[idx_br].z, t.x);
float z_top = mix(vertices[idx_tl].z, vertices[idx_tr].z, t.x);
float z = mix(z_bottom, z_top, t.y);

float depth_normalized = (z - min_z) / (max_z - min_z);
imageStore(outputImage, pixel, vec4(vec3(depth_normalized), 1.0));